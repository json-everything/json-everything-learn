[
  {
    "id": "26b6ebca-58e6-4814-86ea-494ed844c9a8",
    "skip": false,
    "title": "Parsing",
    "background": "JSON Path is a syntax for querying JSON data.\n\n_JsonPath.Net_ provides an implementation that conforms to the official IETF specification, [RFC 9535](https://www.rfc-editor.org/rfc/rfc9535.html).  Like the other guides on this site, this guide will teach you how to use the library _JsonPath.Net_.\n\nHowever, because there are so few implementations of the RFC, and little to no documentation of it, this guide will also teach you the features of JSON Path itself, as described by the RFC.\n\nWe'll start with some basic operations with the library, then we'll move on to what you can do with the syntax.  Later, we'll revisit the library's optional functionality.\n\nUnlike JSON Schema, JSON Logic, or other technologies that are actually represented in JSON, JSON Path is its own syntax, so it must usually be parsed.  The primary way to parse a path is using the static `JsonPath.Parse()` method.\n\r\nIf the path can be parsed successfully, then an implementation is required to be able to evaluate the path without any errors.",
    "docs": "path/basics",
    "api": null,
    "schemaDocs": null,
    "instructions": "Parse the given JSON Path text into a `path` variable.\n",
    "contextCode": "using System.Text.Json;\nusing System.Text.Json.Nodes;\nusing Json.Path;\n\nnamespace LearnJsonEverything;\n\npublic class Lesson : ILessonRunner<PathResult>\n{\n    public PathResult Run(JsonObject test)\n    {\n        var data = test[\"data\"];\n        var pathText = \"$.foo.bar\";\n\n        /* USER CODE */\n\n        return path.Evaluate(data);\n    }\n}",
    "tests": [
      {
        "data": {
          "foo": {
            "bar": "a string"
          }
        },
        "result": [
          "a string"
        ]
      }
    ],
    "solution": "using System.Text.Json;\nusing System.Text.Json.Nodes;\nusing Json.Path;\n\nnamespace LearnJsonEverything;\n\npublic class Lesson : ILessonRunner<PathResult>\n{\n    public PathResult Run(JsonObject test)\n    {\n        var data = test[\"data\"];\n        var pathText = \"$.foo.bar\";\n\n        var path = JsonPath.Parse(pathText);\n\n        return path.Evaluate(data);\n    }\n}"
  },
  {
    "id": "bee48c06-4b02-4e2a-9dd7-97eb1c25e7d1",
    "skip": false,
    "title": "Parsing Safely",
    "background": "Unlike JSON Schema, JSON Logic, or other technologies that are actually represented in JSON, JSON Path is its own syntax, so it must usually be parsed.  The primary way to parse a path is using the static `JsonPath.Parse()` method, but this can throw exceptions when the path string is not valid.\r\n\r\nIf you want to avoid an exception, `JsonPath.TryParse()` exists to parse a path string in a way that does not throw an exception.",
    "docs": "path/basics/#path-in-code",
    "api": null,
    "schemaDocs": null,
    "instructions": "Change the code to safely parse the text.  Return null if parsing fails.",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = test[\"pathText\"].GetValue<string>();\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": {
          "foo": {
            "bar": "a string"
          }
        },
        "pathText": "$['foo'].bar",
        "result": [
          "a string"
        ]
      },
      {
        "data": {
          "foo": {
            "bar": "a string"
          }
        },
        "pathText": "$.['foo'].bar",
        "result": null
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = test[\"pathText\"].GetValue<string>();\r\n\r\n        if (!JsonPath.TryParse(pathText, out var path))\r\n        {\r\n            return null;\r\n        }\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "fc358233-24d7-445c-b083-930f77f45c99",
    "skip": false,
    "title": "JSON Path: The Root",
    "background": "JSON Path is a query syntax that allows simple selection of nodes within JSON data.  That's all it does.\r\n\r\nIt is often paired with other technologies that use JSON Path (or a similar syntax and _claim_ it's JSON Path) to identify locations within JSON data to further perform other operations.  One example of this is the popular JSON processor [`jq`](https://jqlang.github.io/jq/).\r\n\r\nTo build a JSON Path query (a \"path\"), we must always start with the root selector `$`, which corresponds with the root of the data.\r\n\r\n---\r\n\r\nObserve that the expected results in the tests below are always shown in a JSON array.  This is more for convenience than actually representative of the results.  JSON Path doesn't output a JSON array; it outputs a collection of nodes, where each node contains a value and the JSON Path location where value was found.\r\n\r\nFor simple paths, this may seem redundant.  However, as our selection criteria grows more complex and can select multiple or nested values, knowing where those values come can become very important.\r\n\r\nTo see the full results including the paths to the nodes, head over to the [main `json-everything` playground](https://json-everything.net/json-path).",
    "docs": "path/basics",
    "api": null,
    "schemaDocs": null,
    "instructions": "Write a path that just returns the entire JSON data structure.",
    "contextCode": "ususing System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"/* USER CODE */\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": {
          "foo": "bar"
        },
        "result": [
          {
            "foo": "bar"
          }
        ]
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"$\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "1cb6d50e-378b-4710-8994-5d08c59f532d",
    "skip": false,
    "title": "JSON Path: Selecting from Objects",
    "background": "Selectors are the heart of JSON Path.  They determine which nodes are selected.\r\n\r\nA selector is generally expressed inside of a set of square brackets `[]`.  This syntax comes primarily from languages like JavaScript.\r\n\r\nIf the indicated location doesn't exist, it's not an error; simply no node is selected.\r\n\r\nThe _name selector_ selects children of objects by **exactly** matching the key or property name.  It must be enclosed in quotes.\r\n\r\n- Either single- or double-quotes will work, but the start and end must match.\r\n- To include the same quote as the start/end of the string, escape it with a backslash `\\`.\r\n- Otherwise, JSON string escaping generally applies.\r\n",
    "docs": "path/basics",
    "api": null,
    "schemaDocs": null,
    "instructions": "Write a path that selects the value of the `foo` property from the given data.",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"/* USER CODE */\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": {
          "foo": "bar"
        },
        "result": [
          "bar"
        ]
      },
      {
        "data": {
          "foo": 42
        },
        "result": [
          42
        ]
      },
      {
        "data": {
          "foo": [
            "bar"
          ]
        },
        "result": [
          [
            "bar"
          ]
        ]
      },
      {
        "data": {
          "baz": "bar"
        },
        "result": []
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"$['foo']\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "f782b060-7999-4317-a124-8fe4d74ddc93",
    "skip": false,
    "title": "JSON Path: Selecting from Arrays",
    "background": "To select a value from an array, you'll need to use an _index selector_.  These selectors are expressed using a plain (unquoted) number, again inside square brackets.\r\n\r\nIndices in JSON Path are 0-based.\r\n\r\nNegative numbers indicate counting from the end of the array instead of the beginning such that -1 represents the last element in the array, -2 is the one before it, and so on.",
    "docs": "path/basics",
    "api": null,
    "schemaDocs": null,
    "instructions": "Write a path that selects the third value of the given array.",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"/* USER CODE */\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": [
          "string",
          false,
          42
        ],
        "result": [
          42
        ]
      },
      {
        "data": [
          "string",
          false,
          {
            "foo": "bar"
          },
          42
        ],
        "result": [
          {
            "foo": "bar"
          }
        ]
      },
      {
        "data": [
          "string",
          false,
          null,
          42
        ],
        "result": [
          null
        ]
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"$[2]\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "7bca1f8d-7e93-4903-b8bb-32135e983b2a",
    "skip": false,
    "title": "JSON Path: Multiple Selections",
    "background": "You can include multiple selectors within the brackets by comma-separating them.  This can be used either to select multiple nodes from the same data or to select different nodes depending on the data given.\r\n\r\nNodes are returned in the same order as the selectors.\r\n\r\nName selectors with numeric strings do not operate as index selectors, so `[1]` and `['1']` will not select the same nodes.",
    "docs": "path/basics",
    "api": null,
    "schemaDocs": null,
    "instructions": "Write a single path that selects all of required nodes in the right order.",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"/* USER CODE */\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": {
          "foo": "bar"
        },
        "result": [
          "bar"
        ]
      },
      {
        "data": [
          false,
          "bar"
        ],
        "result": [
          "bar"
        ]
      },
      {
        "data": {
          "1": "bar",
          "foo": "baz"
        },
        "result": [
          "bar",
          "baz"
        ]
      },
      {
        "data": {
          "foo": "baz",
          "1": "bar"
        },
        "result": [
          "bar",
          "baz"
        ]
      },
      {
        "data": [
          false,
          "bar",
          "baz"
        ],
        "result": [
          "baz",
          "bar"
        ]
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"$[2, 1,'1','foo']\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "4e9d93b4-08dd-4c9c-bfbf-c8c22f84521d",
    "skip": false,
    "title": "JSON Path: Drilling Down into Data",
    "background": "Most likely, the value you're looking for isn't going to be at the root level, which means that you'll need to dig down into the structure to find it.\r\n\r\nTo accomplish this, keep adding bracket notations for each level.\r\n\r\n```\r\n$['foo'][4]['bar','baz']\r\n```\r\n\r\nEach bracket notation, along with all of the selectors contained within it, is called a _path segment_.\r\n\r\n##### How It Works\r\n\r\nAs you know, a path returns a collection of node/path results.  This is actually just the result of the final path segment.\r\n\r\nFor each path segment, each selector it contains is run against each result from the previous result set.  (The root selector `$` simply selects the entire document to kick off the process.)  The results are then aggregated into a single collection and passed on to the next path segment.  The last path segment simply returns its result set to the user.\r\n\r\nSo for the above path, the following occurs:\r\n\r\n1. `$` - Select the document.\r\n2. `['foo']` - From each node in the result set, if the node is an object, select the `foo` property.  Form a new result set.\r\n3. `[4]` - From each node in the result set, if the node is an array, select the 5th item.  Form a new result set.\r\n4. `['bar','baz']` - From each node in the result set, if the node is an object, select the `bar` and `baz` properties.  Form a new result set.\r\n5. Return the final result set to the user.",
    "docs": "path/basics",
    "api": null,
    "schemaDocs": null,
    "instructions": "Build the data structure that allows all of the paths to select the appropriate data.",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var pathText = test[\"path\"].GetValue<string>();\r\n        var data = JsonNode.Parse(\r\n            \"\"\"\r\n            /* USER CODE */\r\n            \"\"\");\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "path": "$['foo'][1]",
        "result": [
          "bar"
        ]
      },
      {
        "path": "$['bar']['baz']",
        "result": [
          [
            true
          ]
        ]
      },
      {
        "path": "$['bar']['baz'][0]",
        "result": [
          true
        ]
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var pathText = test[\"path\"].GetValue<string>();\r\n        var data = JsonNode.Parse(\r\n            \"\"\"\r\n            {\r\n              \"foo\": [ 42, \"bar\", false ],\r\n              \"bar\": { \"baz\": [ true ] }\r\n            }\r\n            \"\"\");\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "1f189a26-af22-4611-98d7-645ab707cc88",
    "skip": false,
    "title": "JSON Path: Shorthand Name Selector",
    "background": "When a segment only contains a single name selector, it can be expressed in a shorthand using a dot `.` followed by the property name without quotes.  For example `['foo']` becomes `.foo`.\r\n\r\nThere are some requirements that determine when a shorthand name selector can be used:\r\n\r\n- Only the alphanumeric characters `A-Za-z0-9` and the underscore `_` are allowed.\r\n- Must begin with a letter `A-Za-z`\r\n\r\nIf the property you want to select does not meet these criteria, then the bracketed syntax must be used.",
    "docs": "path/basics",
    "api": null,
    "schemaDocs": null,
    "instructions": "Write a path using the shorthand property to select the value under the `bar` property.",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"/* USER CODE */\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": {
          "foo": 42,
          "bar": "string"
        },
        "result": [
          "string"
        ]
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"$.bar\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "5aa82cfd-92f3-4a8f-ab13-e5ba5eb86f0c",
    "skip": false,
    "title": "JSON Path: Recursive Descent",
    "background": "Sometimes you may want to find data, but you don't know where it could be in the structure.  For instance, you may be working with a binary tree of data, and you want to find where a specific value is.\r\n\r\n_**NOTE** In cases like these, it's helpful to see the path in the results.  As mentioned in a prior lesson, you can view the path by working in the [`json-everything` playground](https://json-everything.net/json-path)._\r\n\r\nTo recursively search, you'll need to include the _recursive descent modifier_ `..`.  It's not a selector or a segment in its own right.  Instead it modifies the selectors in the segment following it to look at the entire subtree of nodes rather than just the immediate children.\r\n\r\n```\r\n$..['foo']\r\n```\r\n\r\nor its shorthand version\r\n\r\n```\r\n$..foo\r\n```\r\n\r\nwhich only has two dots total.\r\n\r\nThis syntax will return **all** of the nodes that match.\r\n\r\nIn the result set, a node must appear before its children.\r\n",
    "docs": "path/basics",
    "api": null,
    "schemaDocs": null,
    "instructions": "Write a path to select all of the `foo` values scattered throughout the data.",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"/* USER CODE */\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": {
          "bar": {
            "foo": 42
          },
          "foo": [
            17,
            {
              "foo": 34
            }
          ],
          "baz": {
            "foo": -6
          }
        },
        "result": [
          [
            17,
            {
              "foo": 34
            }
          ],
          42,
          34,
          -6
        ]
      },
      {
        "data": {
          "bar": {
            "foo": 42
          }
        },
        "result": [
          42
        ]
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"$..foo\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "32ac3cd3-22db-4f97-833f-59c250f93f1d",
    "skip": false,
    "title": "JSON Path: Selecting Everything",
    "background": "If you want to select all of the children of an object or array, you'll want to use the _wildcard selector_ `*`.\r\n\r\n```\r\n$[*]\r\n```\r\n\r\nor its shorthand\r\n\r\n```\r\n$.*\r\n```\r\n\r\nThere's not much to this one, but it can be pretty powerful, especially when combined with the recursive descent modifier.\r\n\r\n```\r\n$..*\r\n```",
    "docs": "path/basics",
    "api": null,
    "schemaDocs": null,
    "instructions": "Build a path that recursively selects all of the values.",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"/* USER CODE */\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": [
          42,
          false,
          {
            "foo": "bar"
          }
        ],
        "result": [
          42,
          false,
          {
            "foo": "bar"
          },
          "bar"
        ]
      },
      {
        "data": [
          [
            [
              "string"
            ]
          ]
        ],
        "result": [
          [
            [
              "string"
            ]
          ],
          [
            "string"
          ],
          "string"
        ]
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"$..*\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "e9c056e2-8890-4dbd-ad6f-a7a535f8f323",
    "skip": false,
    "title": "JSON Path: Selecting Ranges of Indices",
    "background": "Selecting a range of indices by listing them all out is impractical.  Instead, use the _array slice selector_.\r\n\r\nThis selector takes inspiration mainly from [Python's slice type](https://docs.python.org/3/library/functions.html#slice) (and [JavaScript's slice function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)).\r\n\r\nThe syntax is simple.  It consists of three integers, a _start_, an _end_, and a _step_, separated by colons `:`, e.g. `0:10:2`.\r\n\r\nAll of the values are optional.  Omitting the start or end just leaves the colon in place, e.g. `:10:2`, `0::2`, or `::2`.  If the step is left out, its colon separator isn't needed either (but leaving it in is also okay), e.g. `0:10` or `0:10:`.\r\n\r\nIf the start is omitted, the default value is 0.  If the end is omitted, the default value is the array length.  If the step is omitted, the default value is 1.\r\n\r\nAs with index selectors, all numbers can be negative, indicating that the counting direction is reversed.\r\n\r\nCounting always begins with the start index and proceeds in increments of the step up to (but **not** including) the end.\r\n\r\nSo that first slice `0:10:2` will select indices 0, 2, 4, 6, and 8, but **not** 10.\r\n\r\nA reverse-direction slice may look like `-1:-11:-2`, and will select indices -1 (the last element), -3, -5, and -9, but **not** -11.",
    "docs": "path/basics",
    "api": null,
    "schemaDocs": null,
    "instructions": "Build a path using an array slice selector to select elements which have indices that are single-digit odd numbers greater than 2.",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"/* USER CODE */\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "result": [
          3,
          5,
          7
        ]
      },
      {
        "data": [
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11
        ],
        "result": [
          3,
          5,
          7,
          9
        ]
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"$[3:11:2]\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "7a6bebd5-2d9d-4c25-82df-d858870e01fe",
    "skip": false,
    "title": "JSON Path: Filtering on Value Existence",
    "background": "The final selector type is the _filter selector_.  This selector takes an expression and selects children for which the expression evaluates to boolean **true**.  There are a lot of things that a filter expression can do, so the syntax is broken up into multiple lessons.\r\n\r\nFilter selectors operate on both arrays and objects by iterating over all of the children and applying an expression.  If the expression evaluates to a boolean **true** (not to be confused with the JSON `true` literal), then the child is selected; boolean **false** (again, not the JSON `false` literal) means the child is not selected.\r\n\r\nFilter selectors start with a question mark `?` followed by an expression.\r\n\r\n_**NOTE** The [original JSON Path](https://goessner.net/articles/JsonPath/) syntax required that the expression be contained in parenthesis `()`, but the specification removed this requirement.  It's still supported, but no longer required._\r\n\r\n---\r\n\r\nThe first filter expressions we'll cover checks whether any value exists at a given location within the item.  This check is called an _existence test_.\r\n\r\nExistence tests return boolean **true** if the value exists, and boolean **false** otherwise.\r\n\r\nThe test consists of a special form of JSON Path that starts with the _local root selector_ `@`.  The local root selector `@` operates just like the root selector `$`, however instead of always referring to the root of the entire JSON document, the local root selector `@` refers to the current child in the filter iteration.\r\n\r\n_**NOTE** The existence test doesn't care what the value is; it only cares that a value is there.  The JSON `null` literal is a value, as is the JSON `false` literal.  If the value exists, boolean **true** is returned._\r\n\r\nFor the path `$[?@]`, you'll get all of the children extracted from their parent because `@` selects the child root, which always must exist (or else it wouldn't be in the iteration).  This path isn't very interesting, so let's add a segment.\r\n\r\nFor the path `$[?@.foo]`, you'll get any child which has a `foo` property.\r\n\r\nTo test for absence, invert the result using the not `!` operator: `$[?!@.foo]`.\r\n\r\nExistence test paths support all segment types.  A non-empty result set translates to a boolean **true** result.",
    "docs": "path/basics",
    "api": null,
    "schemaDocs": null,
    "instructions": "Write a path that selects items with a `foo` property that contains an array with at least 2 items.",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"/* USER CODE */\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": [
          {
            "foo": "bar"
          }
        ],
        "result": []
      },
      {
        "data": [
          {
            "foo": [
              1,
              false,
              [
                97
              ]
            ]
          }
        ],
        "result": [
          {
            "foo": [
              1,
              false,
              [
                97
              ]
            ]
          }
        ]
      },
      {
        "data": [
          {
            "foo": [
              "string"
            ]
          }
        ],
        "result": []
      },
      {
        "data": [
          {
            "foo": [
              "string",
              null
            ]
          }
        ],
        "result": [
          {
            "foo": [
              "string",
              null
            ]
          }
        ]
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"$[?@.foo[1]]\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "718cf6cb-df2d-49ea-89d6-bcd0a2938ae8",
    "skip": false,
    "title": "JSON Path: Filtering on Value",
    "background": "You can also filter by comparing two values in a _comparison test_.  JSON Path offers six comparison operators that should be familiar to users of C-based languages.\r\n\r\n- Equals `==`\r\n- Not equals `!=`\r\n- Less than `<`\r\n- Less than or equal `<=`\r\n- Greater than `>`\r\n- Greater than or equal `>=`\r\n\r\nThe equality operators `==` and `!=` work with all JSON value types, but the inequality operators `<` and friends are only defined for numbers and strings.  Number comparison is based on the numeric value.  String comparison is case-senstive by Unicode code point.\r\n\r\nOnly JSON primitive values (strings, numbers, booleans, and `null`) are supported as literals in expressions; structured values (arrays and objects) are not supported.  String literals can be expressed using single or double quotes and follow the same rules as strings in name selectors.  Other values are expressed raw, with no quotes.\r\n\r\nTo select a value from the current item, the same locally rooted path syntax is used, but with a restriction: segments may only contain a single name or index selector.  This restriction guarantees that only a single value is selected, which is important because the comparisons above are only defined for single values.\r\n\r\nIf no value exists at the location identified by the path, a special value `Nothing` is returned.  `Nothing` is not comparable to any JSON value, including `null`.  Comparisons against `Nothing` **always** produce a boolean **false**.  This has the effect that a successful comparison implies existence.",
    "docs": "path/basics",
    "api": null,
    "schemaDocs": null,
    "instructions": "Build a path that selects all objects for which the `foo` property has a value less that 10.",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"/* USER CODE */\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": [
          {
            "foo": 42
          }
        ],
        "result": []
      },
      {
        "data": [
          {
            "bar": 42
          }
        ],
        "result": []
      },
      {
        "data": [
          {
            "foo": 5
          }
        ],
        "result": [
          {
            "foo": 5
          }
        ]
      },
      {
        "data": [
          {
            "foo": -6
          }
        ],
        "result": [
          {
            "foo": -6
          }
        ]
      },
      {
        "data": [
          {
            "foo": 42
          },
          {
            "bar": 42
          },
          {
            "foo": 5
          },
          {
            "foo": -6
          }
        ],
        "result": [
          {
            "foo": 5
          },
          {
            "foo": -6
          }
        ]
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"$[?@.foo<10]\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "8b5c2785-5ceb-44b5-be38-181ceaf90c10",
    "skip": false,
    "title": "JSON Path: Filtering with Multiple Tests",
    "background": "Multiple tests (both existence and comparison) can be combined using the boolean operators `&&` (\"and\") and `||` (\"or\").  Again, users of C-based languages should be familiar with these.\r\n\r\nBoth kinds of tests can be combined using these operators, and grouping with parentheses `()` works as expected.",
    "docs": "path/basics",
    "api": null,
    "schemaDocs": null,
    "instructions": "Build a path to query for items which both have a `foo` property **and** whose `bar` property is equal to the string `\"baz\"`.",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"/* USER CODE */\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": [
          {
            "foo": 42,
            "bar": "baz"
          }
        ],
        "result": [
          {
            "foo": 42,
            "bar": "baz"
          }
        ]
      },
      {
        "data": [
          {
            "bar": "baz"
          }
        ],
        "result": []
      },
      {
        "data": [
          {
            "foo": 42,
            "bar": "quux"
          }
        ],
        "result": []
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"$[?@.foo && @.bar=='baz']\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "f806ad63-5c73-4d20-80bd-9cb2bb133197",
    "skip": false,
    "title": "JSON Path: Filter Functions - length()",
    "background": "Filter expressions also support functions.  There are five functions defined by the specification.\r\n\r\n- `length()`\r\n- `count()`\r\n- `match()`\r\n- `search()`\r\n- `value()`\r\n\r\nThe specification also allows for custom functions to be defined, but such functions would only be supported where the implementation is explicitly configured to do so.  By defining these functions, the spec declares that they are interoperable.  (There's also an IETF registry where additional functions can be defined that implementations are expected to support, so these would be interoperable as well.)\r\n\r\nThis is also a good opportunity to discuss the type system.  JSON Path defines three basic types:\r\n\r\n- **Values**, which are individual JSON values (objects, arrays, strings, numbers, `true`, `false`, and `null`) and the special value `Nothing`, which represents the absence of a value.\r\n- **Logical**, which is either boolean **true** or boolean **false**.\r\n- **Nodelists**, which are the result of a path evaluation.\r\n\r\nEach function defines its parameter types and return type.  Trying to write a path that uses a function's return incorrectly or passes a parameter incorrectly will result in a parsing failure.\r\n\r\nFor example, `length()` (which will be described in more detail below) returns a value.  It cannot be used as an operand to `&&`.  Trying to do so will result in a parsing failure.\r\n\r\nSingular paths have special consideration in that they may act both as a nodelist and a value.  Speaking more technically, they return a nodelist, and because we always know that it contains at most a single node, we can implicitly extract that node (or `Nothing` if it's empty) and use it as a value.\r\n\r\n---\r\n\r\nThe `length()` function takes a value and returns a numeric value that represents the values's length.\r\n\r\n- For strings, it returns the length in Unicode code points.\r\n- For objects and arrays, it return the number of children.\r\n- For other value types, it returns `Nothing`.\r\n\r\nIt takes a single value parameter and returns a value (number).\r\n\r\nThe function's parameter can be a string literal, a singular path, or a function which returns a value.",
    "docs": "path/basics",
    "api": null,
    "schemaDocs": null,
    "instructions": "Build a path that selects children that have a length greater than 2.",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"/* USER CODE */\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": [
          "a",
          "long",
          "string"
        ],
        "result": [
          "long",
          "string"
        ]
      },
      {
        "data": [
          42,
          1235363,
          false,
          null
        ],
        "result": []
      },
      {
        "data": [
          {
            "enough": 1,
            "kids": 2,
            "already": 3
          }
        ],
        "result": [
          {
            "enough": 1,
            "kids": 2,
            "already": 3
          }
        ]
      },
      {
        "data": [
          [
            "long",
            "enough",
            "array"
          ]
        ],
        "result": [
          [
            "long",
            "enough",
            "array"
          ]
        ]
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"$[?length(@)>2]\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "4a380ba2-0402-4107-bbc2-aa59d30ed1f8",
    "skip": false,
    "title": "JSON Path: Filter Functions - count()",
    "background": "The `count()` function is similar to the `length()` function except that it operates on nodelists instead of values.  Its purpose is to disambiguate between wanting to know the length of an array vs the number of results returned from a path.\r\n\r\nIt takes a single nodelist parameter and returns a value (number).\r\n\r\nThe parameter can be supplied by either a path (doesn't need to be a singular path) or a function which returns a nodelist.",
    "docs": "path/basics",
    "api": null,
    "schemaDocs": null,
    "instructions": "Build a path which returns items that have at least 2 nodes somewhere in their tree.",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"/* USER CODE */\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": [
          {
            "foo": 42
          }
        ],
        "result": []
      },
      {
        "data": [
          {
            "foo": 42,
            "bar": "baz"
          }
        ],
        "result": [
          {
            "foo": 42,
            "bar": "baz"
          }
        ]
      },
      {
        "data": [
          {
            "foo": {
              "bar": "baz"
            }
          }
        ],
        "result": [
          {
            "foo": {
              "bar": "baz"
            }
          }
        ]
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"$[?count(@..*)>=2]\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "616e2915-a7cf-41a6-be40-ae62965479b3",
    "skip": false,
    "title": "JSON Path: Filter Functions - match() & search()",
    "background": "The `match()` and `search()` functions evaluate a string against a regular expression.\r\n\r\nRegular expressions follow the new I-Regexp specification, [RFC 9485](https://www.rfc-editor.org/rfc/rfc9485.html).  Because regular expression support is so widely varied across languages, this specification was developed to define a minimally compatable feature set that _should_ be supported by most languages.  This feature set is what is expected to be supported by all implementations.  Though implementations can choose to support more, such support might not be interoperable.\r\n\r\nThe `match()` function interprets the regular expression as \"implicitly anchored\", meaning that the start `^` and end `$` constraints are implied.  This results in only exact matches.  This behavior comes primarily from JSON Path's roots in XPath.\r\n\r\nThe `search()` function interprets the regular expression as \"explicitly anchored\", meaning that if the user wants to anchor the start `^` and/or end `$` of the expression they must include those characters.  This is the more common usage seen across the internet today, as supported by https://regex101.com/ and many other online interpreters.\r\n\r\nBoth functions take two value parameters, the string content and the regular expression (in that order), and return a boolean **true** if the content matches the regular expression and boolean **false** if it doesn't.\r\n\r\nIf either parameter is not a string, `Nothing` is returned.  (Parsing can only check that values are provided; it cannot check that the values are strings.)\r\n\r\nAs with other functions, these values may be supplied by literals, singular paths, or other functions which return the appropriate values.",
    "docs": "path/basics",
    "api": null,
    "schemaDocs": null,
    "instructions": "Build a path that return values which end with the substring `\"foo\"`.",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"/* USER CODE */\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": {
          "a": "foo start"
        },
        "result": []
      },
      {
        "data": {
          "a": "and foo in the middle"
        },
        "result": []
      },
      {
        "data": {
          "a": "ends with foo"
        },
        "result": [
          "ends with foo"
        ]
      },
      {
        "data": {
          "a": "missing altogether"
        },
        "result": []
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"$[?search(@,'foo$')]\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "4d20a777-6943-4a44-9d6e-2c8dd974270a",
    "skip": false,
    "title": "JSON Path: Filter Functions - value()",
    "background": "The `value()` function allows you to use a regular path where only a singular path may be otherwise allowed.  For instance, if you know your data only has one value under a `foo` property, but you don't know where it is, you can use `@..foo` inside the `value()` function to convert that resulting nodelist into the single result.\r\n\r\nThe `value()` function takes a nodelist and returns a value.  If the nodelist contains a single node, the result is that node's value; otherwise `Nothing` is returned.",
    "docs": "path/basics",
    "api": null,
    "schemaDocs": null,
    "instructions": "Build a path that searches the current item for a `foo` property and returns nodes that have values less than or equal to 100.",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"/* USER CODE */\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": {
          "a": {
            "foo": 10
          }
        },
        "result": [
          {
            "foo": 10
          }
        ]
      },
      {
        "data": {
          "a": {
            "foo": 1000
          }
        },
        "result": []
      },
      {
        "data": {
          "a": {
            "bar": 10
          }
        },
        "result": []
      },
      {
        "data": {
          "a": {
            "foo": 10
          },
          "b": {
            "foo": 45
          },
          "c": {
            "bar": 10
          }
        },
        "result": [
          {
            "foo": 10
          },
          {
            "foo": 45
          }
        ]
      },
      {
        "data": {
          "a": [
            {
              "foo": 10
            },
            {
              "foo": 20
            }
          ]
        },
        "result": []
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"$[?value(@..foo)<=100]\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "d42878da-401c-4187-8ef7-96ac0ed176f3",
    "skip": false,
    "title": "JSON Path: Filter Nesting",
    "background": "Filter selectors can also be nested.  That is, a path build from the local root `@` can also have a filter selector.\r\n\r\nNested filters also use the local root `@`.  The local root `@` is contexted to the expression in which its found.",
    "docs": "path/basics",
    "api": null,
    "schemaDocs": null,
    "instructions": "Build a path that checks for objects and arrays that contain the string `\"foo\"`.",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"/* USER CODE */\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": [
          {
            "foo": "foo"
          }
        ],
        "result": [
          {
            "foo": "foo"
          }
        ]
      },
      {
        "data": [
          [
            "foo"
          ]
        ],
        "result": [
          [
            "foo"
          ]
        ]
      },
      {
        "data": [
          {
            "foo": "bar"
          }
        ],
        "result": []
      },
      {
        "data": [
          [
            "bar"
          ]
        ],
        "result": []
      },
      {
        "data": [
          [
            "foo",
            42
          ],
          [
            "bar",
            "foo"
          ],
          [
            "bar",
            42
          ]
        ],
        "result": [
          [
            "foo",
            42
          ],
          [
            "bar",
            "foo"
          ]
        ]
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = \"$[?@[?@ == 'foo']]\";\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "68646b32-566d-4462-a0c1-e5e8e5291c38",
    "skip": false,
    "title": "Options: Extra Whitespace",
    "background": "The syntax defined by JSON Path only allows whitespace in specific locations.\r\n\r\nThe `TolerateExtraWhitespace` option allows you to put whitespace in these additional locations:\r\n\r\n- before the start of the path (useful if you're extracting the path from another string)\r\n- after the recursive descent modifier `..`\r\n\r\nA final review before the specification was released allowed spaces in most other locations, but these were intentionally disallowed.",
    "docs": "api/JsonPath.Net/PathParsingOptions",
    "api": null,
    "schemaDocs": null,
    "instructions": "Create parsing options and configure it to allow extra whitespace.",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = test[\"path\"].GetValue<string>();\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": {
          "foo": {
            "bar": "baz"
          }
        },
        "path": "$.. bar",
        "result": [
          "baz"
        ]
      },
      {
        "data": {
          "foo": {
            "bar": "baz"
          }
        },
        "path": "  $..bar",
        "result": [
          "baz"
        ]
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = test[\"path\"].GetValue<string>();\r\n\r\n        var options = new PathParsingOptions\r\n        {\r\n            TolerateExtraWhitespace = true\r\n        };\r\n\r\n        var path = JsonPath.Parse(pathText, options);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "6a057d5d-eff6-4dca-8fcb-b9d866e6d255",
    "skip": false,
    "title": "Options: Structured JSON Literals",
    "background": "In developing the JSON Path specification, there were a number of features that didn't make the cut.  However, because _JsonPath.Net_ was developed alongside the specification, it often operated as a test bed for proposals.  As such, some of the features cut from the specification are still available in the library via the `PathParsingOptions` class which can be passed into the parsing methods.\r\n\r\n---\r\n\r\nJSON Path only allows JSON primitives (strings, numbers, booleans, and `null`) to appear in expressions.\r\n\r\nThe `AllowJsonConstructs` option enables using objects and arrays as well.\r\n\r\nThese are JSON literals, so strings inside objects and array (including object keys) **must** use double quotes.",
    "docs": "api/JsonPath.Net/PathParsingOptions",
    "api": null,
    "schemaDocs": null,
    "instructions": "Create parsing options and configure it to allow structured JSON literals in expressions.",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = test[\"path\"].GetValue<string>();\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": {
          "a": "foo",
          "b": [
            1,
            "two",
            3
          ],
          "c": [
            1,
            2,
            3
          ]
        },
        "path": "$[?@ == [1, \"two\", 3]]",
        "result": [
          [
            1,
            "two",
            3
          ]
        ]
      },
      {
        "data": {
          "a": "foo",
          "b": [
            1,
            "two",
            3
          ],
          "c": [
            1,
            2,
            3
          ]
        },
        "path": "$[?@ == [1, 'two', 3]]",
        "result": null
      },
      {
        "data": {
          "a": {
            "foo": 42
          },
          "b": {
            "bar": 43
          },
          "c": {
            "foo": 43
          }
        },
        "path": "$[?@ == {\"foo\": 42}]",
        "result": [
          {
            "foo": 42
          }
        ]
      },
      {
        "data": {
          "a": {
            "foo": 42
          },
          "b": {
            "bar": 43
          },
          "c": {
            "foo": 43
          }
        },
        "path": "$[?@ == {'foo': 42}]",
        "result": null
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = test[\"path\"].GetValue<string>();\r\n\r\n        var options = new PathParsingOptions\r\n        {\r\n            AllowJsonConstructs = true\r\n        };\r\n\r\n        var path = JsonPath.Parse(pathText, options);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "d0044337-24ab-4821-b3c9-c764c35a04bb",
    "skip": false,
    "title": "Options: \"in\" Operator",
    "background": "The `in` operator is supported by many pre-RFC implementations, but it was never adopted by the specification itself.\r\n\r\nThe use cases for the `in` operator _can_ be expressed using the syntax defined by the specification, however doing it with the operator can often be more natural and easier to understand.\r\n\r\n##### A value that contains another value\r\n\r\nThis was the subject of the filter nesting lesson.  The task was to build a path that checks for objects and arrays that contain the string `\"foo\"`.  For which the solution was:\r\n\r\n```\r\n$[?@[?@ == 'foo']]\r\n```\r\n\r\nDoing this with the `in` operator looks like this:\r\n\r\n```\r\n$[?'foo' in @]\r\n```\r\n\r\nSo much simpler.\r\n\r\n##### Values that are one of a set of predefined options\r\n\r\nSuppose we have a set of predefined options, like a set of colors, and we want to find all objects which have a `color` property that is one of those colors.\r\n\r\nThis is pretty straighforward to do with specification syntax, but it's a bit verbose:\r\n\r\n```\r\n$[?@.color == 'red' || @.color == 'white' || @.color == 'green']\r\n```\r\n\r\nThe `in` operator, when combined with structured JSON literals, allows us to make this much more concise:\r\n\r\n```\r\n$[?@.color in [\"red\", \"white\", \"green\"]]\r\n```",
    "docs": "api/JsonPath.Net/PathParsingOptions",
    "api": null,
    "schemaDocs": null,
    "instructions": "Create parsing options and configure it to allow the `in` operator.  (Just for good measure, enable `AllowJsonConstructs`, too.)",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = test[\"path\"].GetValue<string>();\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": {
          "foo": {
            "bar": "baz"
          }
        },
        "path": "$[?'foo' in @]",
        "result": []
      },
      {
        "data": {
          "foo": {
            "bar": "foo"
          }
        },
        "path": "$[?'foo' in @]",
        "result": [
          {
            "bar": "foo"
          }
        ]
      },
      {
        "data": [
          {
            "color": "red"
          },
          {
            "color": true
          }
        ],
        "path": "$[?@.color in [\"red\", \"white\", \"green\"]]",
        "result": [
          {
            "color": "red"
          }
        ]
      },
      {
        "data": [
          {
            "color": "white"
          },
          {
            "color": "blue"
          }
        ],
        "path": "$[?@.color in [\"red\", \"white\", \"green\"]]",
        "result": [
          {
            "color": "white"
          }
        ]
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = test[\"path\"].GetValue<string>();\r\n\r\n        var options = new PathParsingOptions\r\n        {\r\n            AllowJsonConstructs = true,\r\n            AllowInOperator = true\r\n        };\r\n\r\n        var path = JsonPath.Parse(pathText, options);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "21bced0e-8f9d-44f7-b3f6-5e59e5ee022f",
    "skip": false,
    "title": "Options: Math Operators",
    "background": "Though proposed, the specification team elected not to support math operations on values in expressions.  The `AllowMathOperations` option enables this.\r\n\r\nThe supported math operators are:\r\n\r\n- addition `+`\r\n- subtraction `-`\r\n- multiplication `*`\r\n- division `/`\r\n\r\nAll operators work with numbers; addition `+` also concantenates strings.\r\n\r\nFor division `/`, if the divisor is 0, `Nothing` is returned.",
    "docs": "api/JsonPath.Net/PathParsingOptions",
    "api": null,
    "schemaDocs": null,
    "instructions": "Create parsing options and configure it to allow math operations.",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = test[\"path\"].GetValue<string>();\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": [
          {
            "a": 5,
            "b": 3
          },
          {
            "a": 5,
            "b": 6
          }
        ],
        "path": "$[?@.a + @.b > 10]",
        "result": [
          {
            "a": 5,
            "b": 6
          }
        ]
      },
      {
        "data": [
          {
            "a": "foo",
            "b": "bar"
          },
          {
            "a": "fooooo",
            "b": "baaaar"
          }
        ],
        "path": "$[?length(@.a + @.b) > 10]",
        "result": [
          {
            "a": "fooooo",
            "b": "baaaar"
          }
        ]
      },
      {
        "data": [
          {
            "a": 15,
            "b": 5
          },
          {
            "a": 20,
            "b": 10
          },
          {
            "b": 15
          }
        ],
        "path": "$[?@.a / @.b == 2]",
        "result": [
          {
            "a": 20,
            "b": 10
          }
        ]
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = test[\"path\"].GetValue<string>();\r\n\r\n        var options = new PathParsingOptions\r\n        {\r\n            AllowMathOperations = true\r\n        };\r\n\r\n        var path = JsonPath.Parse(pathText, options);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  },
  {
    "id": "23d225a1-3746-4dde-a923-1e477aa00dbe",
    "skip": false,
    "title": "Options: Relative Path Start",
    "background": "The JSON Path specification requires that a path start with the root selector `$`.  However, it was demonstrated that in some use cases, it may make sense to start a path with the local root selector `@`.\r\n\r\nThe `AllowRelativePathStart` option enables this behavior.",
    "docs": "api/JsonPath.Net/PathParsingOptions",
    "api": null,
    "schemaDocs": null,
    "instructions": "Create parsing options and configure it to allow starting a path with the local root selector `@`.",
    "contextCode": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = test[\"path\"].GetValue<string>();\r\n\r\n        var path = JsonPath.Parse(pathText);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}",
    "tests": [
      {
        "data": {
          "foo": 42
        },
        "path": "@.foo",
        "result": [
          42
        ]
      }
    ],
    "solution": "using System.Text.Json;\r\nusing System.Text.Json.Nodes;\r\nusing Json.Path;\r\n\r\nnamespace LearnJsonEverything;\r\n\r\npublic class Lesson : ILessonRunner<PathResult>\r\n{\r\n    public PathResult Run(JsonObject test)\r\n    {\r\n        var data = test[\"data\"];\r\n        var pathText = test[\"path\"].GetValue<string>();\r\n\r\n        var options = new PathParsingOptions\r\n        {\r\n            AllowRelativePathStart = true\r\n        };\r\n\r\n        var path = JsonPath.Parse(pathText, options);\r\n\r\n        return path.Evaluate(data);\r\n    }\r\n}"
  }
]